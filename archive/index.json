[{"content":" \u0026ldquo;Any sufficiently advanced technology is indistinguishable from magic.\u0026rdquo; — Arthur C. Clarke\n Worldview determines methodology, and values dictate life choices. After careful consideration, I have decided to continue exploring the path of magic.\nMy worldview formed during high school, benefiting from my study of science. Due to the objectivity of science, my worldview remains very stable. In a sense, I am a materialist atheist, and my understanding of the world broadly aligns with the scope defined by modern science. During my undergraduate studies in economic statistics, although I received a broad education, I developed a profound understanding of the organization of human society, the functioning of the state apparatus, and personal career choices. This, to a certain extent, shaped my values and subsequently directed my life path. Universal values from both Eastern and Western cultures, such as virtue, benevolence, filial piety, freedom, equality, and universal love, form the cornerstone of my conduct. Faced with challenges, the existentialism of Sartre and Camus, along with Nietzsche\u0026rsquo;s philosophy of the Übermensch, provide me with strength.\nOn the path of knowledge, as an ordinary individual among humanity, what is the meaning of my existence? As part of the vast universe, what is the ultimate purpose of the overall existence of humanity? These questions have troubled me for a long time. In conversations with wise individuals, I have received various answers, and some have even recommended Richard Dawkins' book — \u0026ldquo;The Selfish Gene.\u0026rdquo; While contemplating this issue, I realized that science would eventually become Noah\u0026rsquo;s Ark, carrying human civilization through the endless cosmos.\nAt the beginning of the third decade of the 21st century, the spread of COVID-19, geopolitical power struggles, economic deglobalization, and the rise of nationalism have posed certain obstacles to the development of science. Like all historical events, these difficulties will eventually become inconsequential, and human civilization will transition from the information age to the age of intelligence. From small companies to entire nations, the emergence of new business models and technologies reshapes the existing order and structure. This opportunity is created by the collaboration between scientists in academia and entrepreneurs in the industry. Leveraging my strong foundation in statistics and my experience in deep learning, combined with my relentless efforts, I strive to align my life with this noble cause.\n Our pursuit defines ourselves,\nIt is the imprint of our humanity:\nExperiences that blend passion, dreams, challenges, and mixed emotions,\nThe eternal desire for life to advance without end,\n ","description":"About Page","id":2,"section":"","tags":null,"title":"About","uri":"https://guankuiliu.github.io/about/"},{"content":"Makie.jl is the front end package that defines all plotting functions required to create plot objects. To convert these plot objects to an image, three main back ends which concretely implement all abstract ren-dering capabilities defined in Makie.\n CairoMakie.j: a non-interactive 2D publication-quality vector graphics. GLMakie.j: a interactive 2D and 3D plot-ting in standalone GLFW.jl windows. WGLMakie.jl: a WebGL-based interactive 2D and 3D plotting that runs within browsers.  CairoMakie.jl 1 2 3 4 5 6  # save(\u0026#34;filename.pdf\u0026#34;, fig; pt_per_unit=2)  # save(\u0026#34;filename.png\u0026#34;, fig; px_per_unit=0.5)  using CairoMakie CairoMakie.activate!() fig = scatterlines(1:10, 1:10)   Attributes 1 2  fig, ax, pltobj = scatterlines(1:10) pltobj.attributes   Attributes with 15 entries:\rcolor =\u0026gt; RGBA{Float32}(0.0,0.447059,0.698039,1.0)\rcolormap =\u0026gt; viridis\rcolorrange =\u0026gt; Automatic()\rcycle =\u0026gt; [:color]\rinspectable =\u0026gt; true\rlinestyle =\u0026gt; nothing\rlinewidth =\u0026gt; 1.5\rmarker =\u0026gt; circle\rmarkercolor =\u0026gt; Automatic()\rmarkercolormap =\u0026gt; viridis\rmarkercolorrange =\u0026gt; Automatic()\rmarkersize =\u0026gt; 12\rmodel =\u0026gt; Float32[1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0]\rstrokecolor =\u0026gt; black\rstrokewidth =\u0026gt; 0\r1 2 3 4 5  lines(1:10, (1:10).^2; color = :black, linewidth = 2, linestyle = :dash, figure = (; figure_padding = 5, resolution = (600, 400), font = \u0026#34;sans\u0026#34;, backgroundcolor = :grey90, fontsize = 16), axis = (; xlabel = \u0026#34;x\u0026#34;, ylabel = \u0026#34;x²\u0026#34;, title = \u0026#34;title\u0026#34;, xgridstyle = :dash, ygridstyle = :dash)) current_figure()   1 2 3 4 5 6 7  lines(1:10, (1:10).^2; label = \u0026#34;x²\u0026#34;, linewidth = 2, linestyle = nothing, figure = (; figure_padding = 5, resolution = (600, 400), font = \u0026#34;sans\u0026#34;, backgroundcolor = :grey90, fontsize = 16), axis=(; xlabel = \u0026#34;x\u0026#34;, title = \u0026#34;title\u0026#34;, xgridstyle = :dash, ygridstyle = :dash)) scatterlines!(1:10, (10:-1.0:1).^2; label = \u0026#34;Reverse(x)²\u0026#34;) axislegend(\u0026#34;legend\u0026#34;; position = :ct) current_figure()   1 2 3 4 5 6 7  set_theme!(; resolution = (600, 400), backgroundcolor = (:orange, 0.5), fontsize = 16, font=\u0026#34;sans\u0026#34;, Axis = (backgroundcolor = :grey90, xgridstyle = :dash, ygridstyle = :dash), Legend = (bgcolor = (:red, 0.2), framecolor = :dodgerblue)) lines(1:10, (1:10).^2; label = \u0026#34;x²\u0026#34;, linewidth = 2, linestyle = nothing, axis = (; xlabel = \u0026#34;x\u0026#34;, title = \u0026#34;title\u0026#34;)) scatterlines!(1:10, (10:-1.0:1).^2; label = \u0026#34;Reverse(x)²\u0026#34;) axislegend(\u0026#34;legend\u0026#34;; position = :ct) current_figure()   1 2 3 4 5  using Random: seed! seed!(28) xyvals = randn(100, 3) xyvals[1:5, :]   5×3 Matrix{Float64}:\r0.550992 1.27614 -0.659886\r-1.06587 -0.0287242 0.175126\r-0.721591 -1.84423 0.121052\r0.801169 0.862781 -0.221599\r-0.340826 0.0589894 -1.76359\r1 2 3 4 5 6 7 8 9  set_theme!() # reset the default settings of Makie fig, ax, pltobj = scatter(xyvals[:, 1], xyvals[:, 2]; color = xyvals[:, 3], label = \u0026#34;Bubbles\u0026#34;, colormap = :plasma, markersize = 15 * abs.(xyvals[:, 3]), figure = (; resolution = (600, 400)), axis = (; aspect = DataAspect())) limits!(-3, 3, -3, 3) Legend(fig[1, 2], ax, valign = :top) Colorbar(fig[1, 2], pltobj, height = Relative(3 / 4)) fig   Themes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  seed!(123) y =cumsum(randn(6, 6), dims = 2) seed!(13) xv = yv = LinRange(-3, 0.5, 20) matrix =randn(20, 20) function demo_themes(y, xv, yv, matrix) fig, _ = series(y; labels = [\u0026#34;$i\u0026#34; for i = 1:6], markersize=10, color=:Set1, figure = (; resolution=(600, 300)), axis = (; xlabel = \u0026#34;time(s)\u0026#34;, ylabel = \u0026#34;Amplitude\u0026#34;, title = \u0026#34;Measurements\u0026#34;)) hmap = heatmap!(xv, yv, matrix; colormap = :plasma) limits!(-3.1, 8.5, -6, 5.1) axislegend(\u0026#34;legend\u0026#34;; merge = true) Colorbar(fig[1, 2], hmap) fig end with_theme(theme_dark()) do demo_themes(y, xv, yv, matrix) end   1 2 3  with_theme(theme_black()) do demo_themes(y, xv, yv, matrix) end   1 2 3  with_theme(theme_ggplot2()) do demo_themes(y, xv, yv, matrix) end   1 2 3  with_theme(theme_minimal()) do demo_themes(y, xv, yv, matrix) end   1 2 3  with_theme(theme_light()) do demo_themes(y, xv, yv, matrix) end   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  publication_theme() = Theme(fontsize = 16, font = \u0026#34;CMU Serif\u0026#34;, Axis = (xlabelsize = 20, xgridstyle = :dash, ygridstyle = :dash, xtickalign = 1, ytickalign = 1, yticksize = 10, xticksize = 10, xlabelpadding = -5, xlabel = \u0026#34;x\u0026#34;, ylabel = \u0026#34;y\u0026#34;), Legend = (framecolor = (:black, 0.5), bgcolor = (:white, 0.5)), Colorbar = (ticksize = 16, tickalign = 1, spinewidth = 0.5), ) function plot_with_legend_and_colorbar() fig, ax, _ = scatterlines(1:10; label = \u0026#34;line\u0026#34;) hm = heatmap!(ax, LinRange(6, 9, 15), LinRange(2, 5, 15), randn(15, 15); colormap = :Spectral_11) axislegend(\u0026#34;legend\u0026#34;; position = :lt) Colorbar(fig[1, 2], hm, label = \u0026#34;values\u0026#34;) ax.title = \u0026#34;my custom theme\u0026#34; fig end with_theme(plot_with_legend_and_colorbar, publication_theme())   If something needs to be changed after set_theme!(your_theme), we can do it with update_theme!(resolution=(500, 400), fontsize=18), for example. Another approach will be to pass additional arguments to the with_theme function:\n1 2 3 4 5 6  fig = (resolution = (600, 400), figure_padding = 1, backgroundcolor = :grey90) ax = (; aspect = DataAspect(), xlabel = L\u0026#34;x\u0026#34;, ylabel = L\u0026#34;y\u0026#34;) cbar = (; height = Relative(4 / 5)) with_theme(publication_theme(); fig..., Axis = ax, Colorbar = cbar) do plot_with_legend_and_colorbar() end   Using LaTexStrings.jl 1 2 3 4 5 6 7 8 9 10 11 12 13 14  using LaTeXStrings function LaTeX_Strings() x = 0:0.05:4π lines(x, x -\u0026gt; sin(3x) / (cos(x) + 2) / x; label = L\u0026#34;\\frac{\\sin(3x)}{x(\\cos(x)+2)}\u0026#34;, figure = (; resolution = (600, 400)), axis = (; xlabel = L\u0026#34;x\u0026#34;)) lines!(x, x -\u0026gt; cos(x) / x; label = L\u0026#34;\\cos(x)/x\u0026#34;) lines!(x, x -\u0026gt; exp(-x); label = L\u0026#34;e^{−x}\u0026#34;) limits!(-0.5, 13, -0.6, 1.05) axislegend(L\u0026#34;f(x)\u0026#34;) current_figure() end with_theme(LaTeX_Strings, publication_theme())   1 2 3 4 5 6 7 8 9 10 11 12 13  function multiple_lines() x = collect(0:10) fig = Figure(resolution = (600, 400), font = \u0026#34;CMU Serif\u0026#34;) ax = Axis(fig[1, 1], xlabel = L\u0026#34;x\u0026#34;, ylabel = L\u0026#34;f(x,a)\u0026#34;) for i = 0:10 lines!(ax, x, i .* x; label = latexstring(\u0026#34;$(i)x\u0026#34;)) end axislegend(L\u0026#34;f(x)\u0026#34;; position = :lt, nbanks = 2, labelsize = 14) text!(L\u0026#34;f(x,a) = ax\u0026#34;, position = (4, 80)) fig end multiple_lines()   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function multiple_scatters_and_lines() x = collect(0:10) cycle = Cycle([:color, :linestyle, :marker], covary=true) set_theme!(Lines = (cycle = cycle,), Scatter = (cycle = cycle,)) fig = Figure(resolution = (600, 400), font = \u0026#34;CMU Serif\u0026#34;) ax = Axis(fig[1, 1], xlabel = L\u0026#34;x\u0026#34;, ylabel = L\u0026#34;f(x,a)\u0026#34;) for i in x lines!(ax, x, i .* x; label = latexstring(\u0026#34;$(i)x\u0026#34;)) scatter!(ax, x, i .* x; markersize = 13, strokewidth = 0.25, label = latexstring(\u0026#34;$(i)x\u0026#34;)) end axislegend(L\u0026#34;f(x)\u0026#34;; merge = true, position = :lt, nbanks = 2, labelsize = 14) text!(L\u0026#34;f(x,a) = ax\u0026#34;, position = (4, 80)) set_theme!() # reset to default theme fig end multiple_scatters_and_lines()   Colors and Corlormaps 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function set_colors_and_cycle() # Epicycloid lines x(r, k, θ) = r * (k .+ 1.0) .* cos.(θ) .- r * cos.((k .+ 1.0) .* θ) y(r, k, θ) = r * (k .+ 1.0) .* sin.(θ) .- r * sin.((k .+ 1.0) .* θ) θ = LinRange(0, 6.2π, 1000) axis = (; xlabel = L\u0026#34;x(\\theta)\u0026#34;, ylabel = L\u0026#34;y(\\theta)\u0026#34;, title = \u0026#34;Epicycloid\u0026#34;, aspect = DataAspect()) figure = (; resolution=(600, 400), font=\u0026#34;CMU Serif\u0026#34;) fig, ax, _ = lines(x(1, 1, θ), y(1, 1, θ); color = \u0026#34;firebrick1\u0026#34;, label = L\u0026#34;1.0\u0026#34;, axis = axis, figure = figure) lines!(ax, x(4, 2, θ), y(4, 2, θ); color = :royalblue1, label = L\u0026#34;2.0\u0026#34;) for k = 2.5:0.5:5.5 lines!(ax, x(2k, k, θ), y(2k, k, θ); label = latexstring(\u0026#34;$(k)\u0026#34;)) #cycle end Legend(fig[1, 2], ax, latexstring(\u0026#34;k, r = 2k\u0026#34;), merge = true) fig end set_colors_and_cycle()   1 2 3 4 5 6 7  figure = (; resolution = (600, 400), font = \u0026#34;CMU Serif\u0026#34;) axis = (; xlabel = L\u0026#34;x\u0026#34;, ylabel = L\u0026#34;y\u0026#34;, aspect = DataAspect()) fig, ax, pltobj = heatmap(rand(20, 20); colorrange = (0, 1), colormap = Reverse(:viridis), axis = axis, figure = figure) Colorbar(fig[1, 2], pltobj, label = \u0026#34;Reverse colormap Sequential\u0026#34;) colsize!(fig.layout, 1, Aspect(1, 1.0)) fig   1 2 3 4 5 6 7 8 9  using ColorSchemes figure = (; resolution = (600, 400), font = \u0026#34;CMU Serif\u0026#34;) axis = (; xlabel = L\u0026#34;x\u0026#34;, ylabel = L\u0026#34;y\u0026#34;, aspect = DataAspect()) fig, ax, pltobj = heatmap(randn(20, 20); colorrange = (-2, 2), colormap = \u0026#34;diverging_rainbow_bgymr_45_85_c67_n256\u0026#34;, highclip = :black, lowclip = :white, axis = axis, figure = figure) Colorbar(fig[1, 2], pltobj, label = \u0026#34;Diverging colormap\u0026#34;) colsize!(fig.layout, 1, Aspect(1, 1.0)) fig   1 2 3 4 5 6 7 8 9 10 11 12 13  using Colors, ColorSchemes figure = (; resolution = (600, 400), font = \u0026#34;CMU Serif\u0026#34;) axis = (; xlabel = L\u0026#34;x\u0026#34;, ylabel = L\u0026#34;y\u0026#34;, aspect = DataAspect()) # cmap = ColorScheme(range(colorant\u0026#34;red\u0026#34;, colorant\u0026#34;green\u0026#34;, length = 3)) mycmap = ColorScheme([RGB{Float64}(i, 1.5i, 2i) for i in [0.0, 0.25, 0.35, 0.5]]) fig, ax, pltobj = heatmap(rand(-1:1, 20, 20); colormap = cgrad(mycmap, 3, categorical = true, rev = true), # cgrad and Symbol, mygrays, axis = axis, figure = figure) cbar = Colorbar(fig[1, 2], pltobj, label = \u0026#34;Categories\u0026#34;) cbar.ticks = ([-0.66, 0, 0.66], [\u0026#34;negative\u0026#34;, \u0026#34;neutral\u0026#34;, \u0026#34;positive\u0026#34;]) colsize!(fig.layout, 1, Aspect(1, 1.0)) fig   1 2 3 4 5 6 7 8  figure = (; resolution = (600, 400), font = \u0026#34;CMU Serif\u0026#34;) axis = (; xlabel = L\u0026#34;x\u0026#34;, ylabel = L\u0026#34;y\u0026#34;, aspect = DataAspect()) fig, ax, pltobj = heatmap(rand(20, 20); colorrange = (0, 1), colormap = [\u0026#34;red\u0026#34;, \u0026#34;black\u0026#34;], axis = axis, figure = figure) scatter!(ax, [11], [11], color = (\u0026#34;#C0C0C0\u0026#34;, 0.5), markersize = 150) Colorbar(fig[1, 2], pltobj, label = \u0026#34;2 colors\u0026#34;) colsize!(fig.layout, 1, Aspect(1, 1.0)) fig   Custom cycle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  function new_cycle_theme() # https://nanx.me/ggsci/reference/pal_locuszoom.html  my_colors = [\u0026#34;#D43F3AFF\u0026#34;, \u0026#34;#EEA236FF\u0026#34;, \u0026#34;#5CB85CFF\u0026#34;, \u0026#34;#46B8DAFF\u0026#34;, \u0026#34;#357EBDFF\u0026#34;, \u0026#34;#9632B8FF\u0026#34;, \u0026#34;#B8B8B8FF\u0026#34;] cycle = Cycle([:color, :linestyle, :marker], covary = true) # alltogether my_markers = [:circle, :rect, :utriangle, :dtriangle, :diamond, :pentagon, :cross, :xcross] my_linestyle = [nothing, :dash, :dot, :dashdot, :dashdotdot] Theme(fontsize = 16, font = \u0026#34;CMU Serif\u0026#34;, colormap = :linear_bmy_10_95_c78_n256, palette = (color = my_colors, marker = my_markers, linestyle = my_linestyle), Lines = (cycle = cycle,), Scatter = (cycle = cycle,), Axis = (xlabelsize = 20, xgridstyle = :dash, ygridstyle = :dash, xtickalign = 1, ytickalign = 1, yticksize = 10, xticksize = 10, xlabelpadding = -5, xlabel = \u0026#34;x\u0026#34;, ylabel = \u0026#34;y\u0026#34;), Legend = (framecolor = (:black, 0.5), bgcolor = (:white, 0.5)), Colorbar = (ticksize = 16, tickalign = 1, spinewidth = 0.5)) end function scatters_and_lines() x = collect(0:10) xh = LinRange(4, 6, 25) yh = LinRange(70, 95, 25) h = randn(25, 25) fig = Figure(resolution = (600, 400), font = \u0026#34;CMU Serif\u0026#34;) ax = Axis(fig[1, 1], xlabel = L\u0026#34;x\u0026#34;, ylabel = L\u0026#34;f(x,a)\u0026#34;) for i in x lines!(ax, x, i .* x; label = latexstring(\u0026#34;$(i)x\u0026#34;)) scatter!(ax, x, i .* x; markersize = 13, strokewidth = 0.25, label = latexstring(\u0026#34;$(i)x\u0026#34;)) end hm = heatmap!(xh, yh, h) axislegend(L\u0026#34;f(x)\u0026#34;; merge = true, position = :lt, nbanks = 2, labelsize = 14) Colorbar(fig[1, 2], hm, label = \u0026#34;new default colormap\u0026#34;) limits!(ax, -0.5, 10.5, -5, 105) colgap!(fig.layout, 5) fig end with_theme(scatters_and_lines, new_cycle_theme())   Layouts 1 2 3 4 5 6 7 8 9 10 11 12 13  function first_layout() seed!(123) x, y, z = randn(6), randn(6), randn(6) fig = Figure(resolution = (600, 400), backgroundcolor = :grey90) ax = Axis(fig[1, 1], backgroundcolor = :white) pltobj = scatter!(ax, x, y; color = z, label=\u0026#34;scatters\u0026#34;) lines!(ax, x, 1.1y; label = \u0026#34;line\u0026#34;) Legend(fig[2, 1:2], ax, \u0026#34;labels\u0026#34;, orientation = :horizontal) Colorbar(fig[1, 2], pltobj, label = \u0026#34;colorbar\u0026#34;) fig end first_layout()   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function first_layout_fixed() seed!(123) x, y, z = randn(6), randn(6), randn(6) fig = Figure(figure_padding = (0, 3, 5, 2), resolution = (600, 400), backgroundcolor = :grey90, font = \u0026#34;CMU Serif\u0026#34;) ax = Axis(fig[1, 1], xlabel = L\u0026#34;x\u0026#34;, ylabel = L\u0026#34;y\u0026#34;, title = \u0026#34;Layout example\u0026#34;, backgroundcolor = :white) pltobj = scatter!(ax, x, y; color = z, label = \u0026#34;scatters\u0026#34;) lines!(ax, x, 1.1y, label = \u0026#34;line\u0026#34;) Legend(fig[2, 1:2], ax, \u0026#34;Labels\u0026#34;, orientation = :horizontal, tellheight = true, titleposition = :left) Colorbar(fig[1, 2], pltobj, label = \u0026#34;colorbar\u0026#34;) # additional aesthetics  Box(fig[1, 1, Right()], color = (:slateblue1, 0.35)) Label(fig[1, 1, Right()], \u0026#34;protrusion\u0026#34;, fontsize = 18, rotation = pi / 2, padding = (3, 3, 3, 3)) Label(fig[1, 1, TopLeft()], \u0026#34;(a)\u0026#34;, fontsize = 18, padding = (0, 3, 8, 0)) colgap!(fig.layout, 5) rowgap!(fig.layout, 5) fig end first_layout_fixed()   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  function complex_layout_double_axis() seed!(123) x = LinRange(0, 1, 10) y = LinRange(0, 1, 10) z = rand(10, 10) fig = Figure(resolution = (600, 400), font = \u0026#34;CMU Serif\u0026#34;, backgroundcolor = :grey90) ax1 = Axis(fig, xlabel = L\u0026#34;x\u0026#34;, ylabel=L\u0026#34;y\u0026#34;) ax2 = Axis(fig, xlabel = L\u0026#34;x\u0026#34;) heatmap!(ax1, x, y, z; colorrange = (0, 1)) series!(ax2, abs.(z[1:4, :]); labels = [\u0026#34;lab $i\u0026#34; for i = 1:4], color = :Set1_4) hm = scatter!(10x, y; color = z[1, :], label= \u0026#34;dots\u0026#34;, colorrange = (0, 1)) hideydecorations!(ax2, ticks = false, grid = false) linkyaxes!(ax1, ax2) #layout fig[1, 1] = ax1 fig[1, 2] = ax2 Label(fig[1, 1, TopLeft()], \u0026#34;(a)\u0026#34;, textsize = 18, padding = (0, 6, 8, 0)) Label(fig[1, 2, TopLeft()], \u0026#34;(b)\u0026#34;, textsize = 18, padding = (0, 6, 8, 0)) Colorbar(fig[2, 1:2], hm, label = \u0026#34;colorbar\u0026#34;, vertical = false, flipaxis = false) Legend(fig[1, 3], ax2, \u0026#34;Legend\u0026#34;) colgap!(fig.layout, 5) rowgap!(fig.layout, 5) fig end complex_layout_double_axis()   1 2 3 4 5 6 7 8 9 10 11 12 13 14  function squares_layout() seed!(123) letters = reshape(collect(\u0026#39;a\u0026#39;:\u0026#39;d\u0026#39;), (2, 2)) fig = Figure(resolution = (600, 400), fontsize = 14, font = \u0026#34;CMU Serif\u0026#34;, backgroundcolor = :grey90) axs = [Axis(fig[i, j], aspect = DataAspect()) for i = 1:2, j = 1:2] hms = [heatmap!(axs[i, j], randn(10, 10), colorrange = (-2, 2)) for i = 1:2, j = 1:2] Colorbar(fig[1:2, 3], hms[1], label = \u0026#34;colorbar\u0026#34;) [Label(fig[i, j, TopLeft()], \u0026#34;($(letters[i, j]))\u0026#34;, textsize = 16, padding = (-2, 0, -20, 0)) for i = 1:2, j = 1:2] colgap!(fig.layout, 5) rowgap!(fig.layout, 5) fig end squares_layout()   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  using Dates function mixed_mode_layout() seed!(123) longlabels = [\u0026#34;$(today() − Day(1))\u0026#34;, \u0026#34;$(today())\u0026#34;, \u0026#34;$(today() + Day(1))\u0026#34;] fig = Figure(resolution = (600, 400), fontsize = 12, backgroundcolor = :grey90, font = \u0026#34;CMU Serif\u0026#34;) ax1 = Axis(fig[1, 1]) ax2 = Axis(fig[1, 2], xticklabelrotation = pi / 2, alignmode = Mixed(bottom = 0), xticks = ([1, 5, 10], longlabels)) ax3 = Axis(fig[2, 1:2]) ax4 = Axis(fig[3, 1:2]) axs = [ax1, ax2, ax3, ax4] [lines!(ax, 1:10, rand(10)) for ax in axs] hidexdecorations!(ax3; ticks = false, grid = false) Box(fig[2:3, 1:2, Right()], color = (:slateblue1, 0.35)) Label(fig[2:3, 1:2, Right()], \u0026#34;protrusion\u0026#34;, rotation = pi / 2, textsize = 14, padding = (3, 3, 3, 3)) Label(fig[1, 1:2, Top()], \u0026#34;Mixed alignmode\u0026#34;, textsize = 16, padding = (0, 0, 15, 0)) colsize!(fig.layout, 1, Auto(2)) rowsize!(fig.layout, 2, Auto(0.5)) rowsize!(fig.layout, 3, Auto(0.5)) rowgap!(fig.layout, 1, 15) rowgap!(fig.layout, 2, 0) colgap!(fig.layout, 5) fig end mixed_mode_layout()   Nested Axis (subplots) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function nested_sub_plot!(fig) color = rand(RGBf) ax1 = Axis(fig[1, 1], backgroundcolor = (color, 0.25)) ax2 = Axis(fig[1, 2], backgroundcolor = (color, 0.25)) ax3 = Axis(fig[2, 1:2], backgroundcolor = (color, 0.25)) ax4 = Axis(fig[1:2, 3], backgroundcolor = (color, 0.25)) return (ax1, ax2, ax3, ax4) end function main_figure() fig = Figure() Axis(fig[1, 1]) nested_sub_plot!(fig[1, 2]) nested_sub_plot!(fig[1, 3]) nested_sub_plot!(fig[2, 1:3]) fig end main_figure()   Nested GridLayout 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function nested_Grid_Layouts() fig = Figure(backgroundcolor = RGBf(0.96, 0.96, 0.96)) ga = fig[1, 1] = GridLayout() gb = fig[1, 2] = GridLayout() gc = fig[1, 3] = GridLayout() gd = fig[2, 1:3] = GridLayout() gA = Axis(ga[1, 1]) nested_sub_plot!(gb) axsc = nested_sub_plot!(gc) nested_sub_plot!(gd) [hidedecorations!(axsc[i], grid = false, ticks = false) for i = 1:length(axsc)] colgap!(gc, 5) rowgap!(gc, 5) rowsize!(fig.layout, 2, Auto(0.5)) colsize!(fig.layout, 1, Auto(0.5)) fig end nested_Grid_Layouts()   Inset plots 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  function add_box_inset(fig; left = 100, right = 250, bottom = 200, top = 300, bgcolor = :grey90) inset_box = Axis(fig, bbox = BBox(left, right, bottom, top), xticklabelsize = 12, yticklabelsize = 12, backgroundcolor = bgcolor) # bring content upfront  translate!(inset_box.scene, 0, 0, 10) elements = keys(inset_box.elements) filtered = filter(ele -\u0026gt; ele != :xaxis \u0026amp;\u0026amp; ele != :yaxis, elements) foreach(ele -\u0026gt; translate!(inset_box.elements[ele], 0, 0, 9), filtered) return inset_box end function figure_box_inset() fig = Figure(resolution = (650, 400)) ax = Axis(fig[1, 1], backgroundcolor = :white) inset_ax1 = add_box_inset(fig; left = 100, right = 250, bottom = 200, top = 300, bgcolor = :grey90) inset_ax2 = add_box_inset(fig; left = 500, right = 600, bottom = 100, top = 200, bgcolor = (:white, 0.65)) lines!(ax, 1:10) lines!(inset_ax1, 1:10) scatter!(inset_ax2, 1:10, color = :black) fig end figure_box_inset()   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  function add_axis_inset(; pos = fig[1, 1], halign = 0.1, valign = 0.5,width = Relative(0.5), height = Relative(0.35), bgcolor = :lightgray) inset_box = Axis(pos, width = width, height = height, halign = halign, valign = valign, xticklabelsize = 12, yticklabelsize = 12, backgroundcolor = bgcolor) # bring content upfront translate!(inset_box.scene, 0, 0, 10) return inset_box end function figure_axis_inset() fig = Figure(resolution = (600, 400)) ax = Axis(fig[1, 1], backgroundcolor = :white) inset_ax1 = add_axis_inset(; pos = fig[1, 1], halign = 0.1, valign = 0.65, width=Relative(0.3), height = Relative(0.3), bgcolor = :grey90) inset_ax2 = add_axis_inset(; pos = fig[1, 1], halign = 1, valign = 0.25, width = Relative(0.25), height = Relative(0.3), bgcolor = (:white, 0.65)) lines!(ax, 1:10) lines!(inset_ax1, 1:10) scatter!(inset_ax2, 1:10, color = :black) fig end figure_axis_inset()   GLMakie.jl Scatters and Lines 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  using GLMakie GLMakie.activate!() function scatters_in_3D() seed!(123) xyz = randn(10, 3) x, y, z = xyz[:, 1], xyz[:, 2], xyz[:, 3] fig = Figure(resolution = (1200, 400)) ax1 = Axis3(fig[1, 1]; aspect = (1, 1, 1), perspectiveness = 0.5) ax2 = Axis3(fig[1, 2]; aspect = (1, 1, 1), perspectiveness = 0.5) ax3 = Axis3(fig[1, 3]; aspect = :data, perspectiveness = 0.5) scatter!(ax1, x, y, z; markersize = 50) meshscatter!(ax2, x, y, z; markersize = 0.25) hm = meshscatter!(ax3, x, y, z; markersize = 0.25, marker = FRect3D(Vec3f0(0), Vec3f0(1)), color = 1:size(xyz)[2], colormap = :plasma, transparency = false) Colorbar(fig[1, 4], hm, label = \u0026#34;values\u0026#34;, height = Relative(0.5)) fig end scatters_in_3D()   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function lines_in_3D() seed!(123) xyz = randn(10, 3) x, y, z = xyz[:, 1], xyz[:, 2], xyz[:, 3] fig = Figure(resolution = (1300, 400)) ax1 = Axis3(fig[1, 1]; aspect = (1, 1, 1), perspectiveness = 0.5) ax2 = Axis3(fig[1, 2]; aspect = (1, 1, 1), perspectiveness = 0.5) ax3 = Axis3(fig[1, 3]; aspect = :data, perspectiveness = 0.5) lines!(ax1, x, y, z; color = 1:size(xyz)[2], linewidth = 3) scatterlines!(ax2, x, y, z; markersize = 50) hm = meshscatter!(ax3, x, y, z; markersize = 0.2, color = 1:size(xyz)[2]) lines!(ax3, x, y, z; color = 1:size(xyz)[2]) Colorbar(fig[2, 1], hm; label=\u0026#34;values\u0026#34;, height = 15, vertical = false, flipaxis = false, ticksize = 15, tickalign = 1, width = Relative(3.55 / 4)) fig end lines_in_3D()   Surfaces, wireframe, contour, contourf and contour3d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  function peaks(; n = 49) x = LinRange(-3, 3, n) y = LinRange(-3, 3, n) a = 3 * (1 .- x\u0026#39;) .^ 2 .* exp.(-(x\u0026#39; .^ 2) .- (y .+ 1) .^ 2) b = 10 * (x\u0026#39; / 5 .- x\u0026#39; .^ 3 .- y .^ 5) .* exp.(-x\u0026#39; .^ 2 .- y .^ 2) c = 1 / 3 * exp.(-(x\u0026#39; .+ 1) .^ 2 .- y .^ 2) return (x, y, a .- b .- c) end function plot_peaks_function() x, y, z = peaks() x2, y2, z2 = peaks(; n = 15) fig = Figure(resolution = (1300, 400), fontsize = 26) axs = [Axis3(fig[1, i]; aspect = (1, 1, 1)) for i = 1:3] hm = surface!(axs[1], x, y, z) wireframe!(axs[2], x2, y2, z2) contour3d!(axs[3], x, y, z; levels = 20) Colorbar(fig[1, 4], hm, height = Relative(0.5)) fig end plot_peaks_function()   1 2 3 4 5 6 7 8 9 10 11 12  function heatmap_contour_and_contourf() x, y, z = peaks() fig = Figure(resolution = (1300, 400), fontsize = 26) axs = [Axis(fig[1, i]; aspect = DataAspect()) for i = 1:3] hm = heatmap!(axs[1], x, y, z) contour!(axs[2], x, y, z; levels = 20) contourf!(axs[3], x, y, z) Colorbar(fig[1, 4], hm, height = Relative(0.5)) fig end heatmap_contour_and_contourf()   1 2 3 4 5 6 7 8 9 10 11 12  function heatmap_contour_and_contourf_in_a_3d_plane() x, y, z = peaks() fig = Figure(resolution = (1600, 400), fontsize = 26) axs = [Axis3(fig[1, i]) for i = 1:3] hm = heatmap!(axs[1], x, y, z) contour!(axs[2], x, y, z; levels = 20) contourf!(axs[3], x, y, z) Colorbar(fig[1, 4], hm, height = Relative(0.5)) fig end heatmap_contour_and_contourf_in_a_3d_plane()   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  using TestImages function mixing_surface_contour3d_contour_and_contourf() img = testimage(\u0026#34;coffee.png\u0026#34;) x, y, z = peaks() cmap = :Spectral_11 fig = Figure(resolution = (1200, 600), fontsize = 26) ax1 = Axis3(fig[1, 1]; aspect = (1, 1, 1), elevation=pi / 6, xzpanelcolor=(:black, 0.75), perspectiveness = 0.5, yzpanelcolor = :black, zgridcolor = :grey70, ygridcolor = :grey70, xgridcolor = :grey70) ax2 = Axis3(fig[1, 3]; aspect = (1, 1, 1), elevation = pi / 6, perspectiveness = 0.5) hm = surface!(ax1, x, y, z; colormap = (cmap, 0.95), shading = true) contour3d!(ax1, x, y, z .+ 0.02; colormap = cmap, levels = 20, linewidth = 2) xmin, ymin, zmin = minimum(ax1.finallimits[]) xmax, ymax, zmax = maximum(ax1.finallimits[]) contour!(ax1, x, y, z; colormap = cmap, levels = 20, transformation = (:xy, zmax)) contourf!(ax1, x, y, z; colormap = cmap, transformation = (:xy, zmin)) Colorbar(fig[1, 2], hm, width = 15, ticksize = 15, tickalign = 1, height = Relative(0.35)) # transformations into planes  heatmap!(ax2, x, y, z; colormap = :viridis, transformation = (:yz, 3.5)) contourf!(ax2, x, y, z; colormap = :CMRmap, transformation = (:xy, -3.5)) contourf!(ax2, x, y, z; colormap = :bone_1, transformation = (:xz, 3.5)) image!(ax2, -3 .. 3, -3 .. 2, rotr90(img); transformation = (:xy, 3.8)) xlims!(ax2, -3.8, 3.8) ylims!(ax2, -3.8, 3.8) zlims!(ax2, -3.8, 3.8) fig end mixing_surface_contour3d_contour_and_contourf()   Arrows and Streamplots 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  using LinearAlgebra function arrows_and_streamplot_in_3d() ps = [Point3f0(x, y, z) for x = -3:1:3 for y = -3:1:3 for z = -3:1:3] ns = map(p -\u0026gt; 0.1 * rand() * Vec3f0(p[2], p[3], p[1]), ps) lengths = norm.(ns) flowField(x, y, z) = Point(-y + x * (-1 + x^2 + y^2)^2, x + y * (-1 + x^2 + y^2)^2, z + x * (y - z^2)) fig = Figure(resolution = (1200, 600), fontsize = 26) axs = [Axis3(fig[1, i]; aspect =( 1, 1, 1), perspectiveness = 0.5) for i = 1:2] arrows!(axs[1], ps, ns, color = lengths, arrowsize = Vec3f0(0.2, 0.2, 0.3), linewidth = 0.1) streamplot!(axs[2], flowField, -4 .. 4, -4 .. 4, -4 .. 4, colormap = :plasma, gridsize = (7, 7), arrow_size = 0.25, linewidth = 1) fig end arrows_and_streamplot_in_3d()   Meshes and Volumes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  using GeometryBasics function mesh_volume_contour() # mesh objects rectMesh = FRect3D(Vec3f0(-0.5), Vec3f0(1)) recmesh = GeometryBasics.mesh(rectMesh) sphere = Sphere(Point3f0(0), 1) # https://juliageometry.github.io/GeometryBasics.jl/stable/primitives/  spheremesh = GeometryBasics.mesh(Tesselation(sphere, 64)) # uses 64 for tesselation, a smoother sphere  colors = [rand() for v in recmesh.position] # cloud points for volume  x = y = z = 1:10 vals = randn(10, 10, 10) fig = Figure(resolution = (1200, 400)) axs = [Axis3(fig[1, i]; aspect = (1, 1, 1), perspectiveness = 0.5) for i = 1:3] mesh!(axs[1], recmesh; color = colors, colormap = :rainbow, shading = false) mesh!(axs[1], spheremesh; color = (:white, 0.25), transparency = true) volume!(axs[2], x, y, z, vals; colormap = Reverse(:plasma)) contour!(axs[3], x, y, z, vals; colormap = Reverse(:plasma)) fig end mesh_volume_contour()   1 2 3 4 5 6 7 8 9 10 11  using GeometryBasics, ColorSchemes seed!(123) spheresGrid = [Point3f0(i, j, k) for i in 1:2:10 for j in 1:2:10 for k in 1:2:10] colorSphere = [RGBA(i * 0.1, j * 0.1, k * 0.1, 0.75) for i in 1:2:10 for j in 1:2:10 for k in 1:2:10] spheresPlane = [Point3f0(i, j, k) for i in 1:2.5:20 for j in 1:2.5:10 for k in 1:2.5:4] cmap = get(colorschemes[:plasma], LinRange(0, 1, 50)) colorsPlane = cmap[rand(1:50,50)] rectMesh = FRect3D(Vec3f0(-1, -1, 2.1), Vec3f0(22, 11, 0.5)) recmesh = GeometryBasics.mesh(rectMesh) colors = [RGBA(rand(4)...) for v in recmesh.position]   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function grid_spheres_and_rectangle_as_plate() fig = with_theme(theme_dark()) do fig = Figure(resolution = (1200, 600)) ax1 = Axis3(fig[1, 1]; aspect = :data, perspectiveness = 0.5, azimuth = 0.72) ax2 = Axis3(fig[1, 2]; aspect = :data, perspectiveness = 0.5) meshscatter!(ax1, spheresGrid; color = colorSphere, markersize = 1, shading = false) meshscatter!(ax2, spheresPlane; color = colorsPlane, markersize = 0.75, lightposition = Vec3f0(10, 5, 2), ambient = Vec3f0(0.95, 0.95, 0.95), backlight = 1.0f0) mesh!(recmesh; color = colors, colormap = :rainbow, shading = false) limits!(ax1, 0, 10, 0, 10, 0, 10) fig end fig end grid_spheres_and_rectangle_as_plate()   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  x, y, z = peaks(; n = 15) δx = (x[2] - x[1]) / 2 δy = (y[2] - y[1]) / 2 cbarPal = :Spectral_11 ztmp = (z .- minimum(z)) ./ (maximum(z .- minimum(z))) cmap = get(colorschemes[cbarPal], ztmp) cmap2 = reshape(cmap, size(z)) ztmp2 = abs.(z) ./ maximum(abs.(z)) .+ 0.15 function histogram_or_bars_in_3d() fig= Figure(resolution = (1200, 600), fontsize = 26) ax1 = Axis3(fig[1, 1]; aspect = (1, 1, 1), elevation = π/6, perspectiveness= 0.5) ax2 = Axis3(fig[1, 2]; aspect = (1, 1, 1), perspectiveness = 0.5) rectMesh = FRect3D(Vec3f0(-0.5, -0.5, 0), Vec3f0(1, 1, 1)) meshscatter!(ax1, x, y, 0 * z, marker = rectMesh, color = z[:], markersize = Vec3f0.(2δx, 2δy, z[:]), colormap = :Spectral_11, shading = false) limits!(ax1, -3.5, 3.5, -3.5, 3.5, -7.45, 7.45) meshscatter!(ax2, x, y, 0 * z, marker = rectMesh, color = z[:], markersize = Vec3f0.(2δx, 2δy, z[:]), colormap = (:Spectral_11, 0.25), shading = false, transparency = true) for (idx, i) in enumerate(x), (idy, j) in enumerate(y) rectMesh = FRect3D(Vec3f0(i - δx, j - δy, 0), Vec3f0(2δx, 2δy, z[idx, idy])) recmesh = GeometryBasics.mesh(rectMesh) lines!(ax2, recmesh; color = (cmap2[idx, idy], ztmp2[idx, idy])) end fig end histogram_or_bars_in_3d()   Filled Line and Band 1 2 3 4 5 6 7 8 9 10 11 12 13  function filled_line_and_linesegments_in_3D() xs = LinRange(-3, 3, 10) lower = [Point3f0(i, -i, 0) for i in LinRange(0, 3, 100)] upper = [Point3f0(i, -i, sin(i) * exp(-(i + i))) for i in range(0, 3, length = 100)] fig = Figure(resolution = (1200, 600)) axs = [Axis3(fig[1, i]; elevation = pi/6, perspectiveness=0.5) for i = 1:2] band!(axs[1], lower, upper, color = repeat(norm.(upper), outer = 2), colormap = :CMRmap) lines!(axs[1], upper, color = :black) linesegments!(axs[2], cos.(xs), xs, sin.(xs), linewidth = 5, color = 1:length(xs)) fig end filled_line_and_linesegments_in_3D()    Storopoli, Huijzer and Alonso (2021). Julia Data Science. https://juliadatascience.io. ISBN: 9798489859165.  ","description":"Some examples of Makie.jl visualization","id":5,"section":"blogs","tags":["Julia"],"title":"Data Visualization with Makie","uri":"https://guankuiliu.github.io/blogs/2023/2023-01-11-julia_data_science/"},{"content":"Plots 1 2 3 4 5 6  # pkg\u0026gt; add Plots PyPlot GR UnicodePlots using Plots # pyplot() # PyPlot backend eq(d) = -7.65 * sind(d) + 9.87 * sind(2d + 206) plot(eq, 1:365)   UnicodePlots 1 2 3 4 5  # add UnicodePlots using UnicodePlots FirstLinePlot = lineplot([1, 2, 3, 7], [1, 2, -5, 7], title = \u0026#34;First Line Plot\u0026#34;, border = :dotted) UnicodePlots.savefig(FirstLinePlot, \u0026#34;FirstLinePlot.txt\u0026#34;)   1 2  FirstDensityPlot = densityplot(collect(1:100), randn(100), border = :dotted) UnicodePlots.savefig(FirstDensityPlot, \u0026#34;FirstDensityPlot.txt\u0026#34;)   VegaLite 1 2 3 4 5 6  # add VegaLite using VegaLite X = [\u0026#34;Monday\u0026#34;, \u0026#34;Tuesday\u0026#34;, \u0026#34;Wednesday\u0026#34;, \u0026#34;Thrusday\u0026#34;, \u0026#34;Friday\u0026#34;,\u0026#34;Saturday\u0026#34;,\u0026#34;Sunday\u0026#34;] Y = [11, 11, 15, 13, 12, 13, 10] P = pie(X, Y)   Winston 1 2 3 4 5 6 7 8 9  using Winston x = range(0, stop = 3pi, length = 100); c = cos.(x); s = sin.(x); p = FramedPlot(title = \u0026#34;Winston Graphics!\u0026#34;, xlabel = \u0026#34;\\\\Sigma x^2_i\u0026#34;, ylabel = \u0026#34;\\\\Theta_i\u0026#34;) add(p, FillBetween(x, c, x, s)) add(p, Curve(x, c, color = \u0026#34;black\u0026#34;)) add(p, Curve(x, s, color = \u0026#34;red\u0026#34;))   Gadfly 1 2 3 4 5  using Gadfly using RDatasets iris = dataset(\u0026#34;datasets\u0026#34;, \u0026#34;iris\u0026#34;); Gadfly.plot(iris, x = :SepalLength, y = :SepalWidth, Geom.point)   1  Gadfly.plot(iris, x = :SepalLength, y = :SepalWidth, Geom.point, Geom.line)   1  Gadfly.plot(iris, x = :SepalLength, y = :SepalWidth, color = :Species, Geom.point)   Compose 1 2 3 4  using Compose composition = compose(compose(context(), rectangle()), fill(\u0026#34;tomato\u0026#34;)) draw(SVG(\u0026#34;simple.svg\u0026#34;, 6cm, 6cm), composition)   1 2 3  composition = compose(context(), (context(), Compose.circle(), fill(\u0026#34;bisque\u0026#34;)), (context(), rectangle(), fill(\u0026#34;tomato\u0026#34;))) composition |\u0026gt; SVG(\u0026#34;simple2.svg\u0026#34;)   PyPlot 1 2 3 4 5 6 7  using Conda Conda.add(\u0026#34;matplotlib\u0026#34;) using PyPlot x = range(0; stop = 2*pi, length = 500); y = sin.(3 * x + 4 * cos.(2 * x)); PyPlot.plot(x, y, color = \u0026#34;blue\u0026#34;, linewidth = 1.0, linestyle = \u0026#34;--\u0026#34;)   1  surf(rand(20, 30))   Gaston 1 2 3 4 5  using PGFPlots R = Axis([Plots.Linear(x-\u0026gt;sin(3x)*exp(-0.3x), (0,8), legendentry = L\u0026#34;$\\sin(3x)*exp(-0.3x)$\u0026#34;), Plots.Linear(x-\u0026gt;sqrt(x)/(1+x^2), (0,8), legendentry = L\u0026#34;$\\sqrt{2x}/(1+x^2)$\u0026#34;)]) save(\u0026#34;Plot_LinearPGF.svg\u0026#34;, R)    Summary from《LEARN JULIA PROGRAMMING》  ","description":"Several commonly used Julia plotting packages","id":6,"section":"blogs","tags":["Julia"],"title":"Julia plotting packages","uri":"https://guankuiliu.github.io/blogs/2023/2023-01-09-julia_graphics/"},{"content":"个人简历！\n","description":"My portfolio, repos, works overview page","id":8,"section":"","tags":null,"title":"Showcase overview","uri":"https://guankuiliu.github.io/resume/"}]